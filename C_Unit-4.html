<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <title>C Programming and Problem Solving</title>
    <style>
        body {
            font-family: 'Poppins', Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }

        .back-link {
            display: inline-block;
            margin-top: 30px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            font-weight: bold;
            border-radius: 6px;
            transition: background-color 0.3s, transform 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .back-link:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .back-link:active {
            transform: scale(0.98);
        }

        .header {
            background-color: #343a40;
            color: white;
            padding: 20px 0;
            text-align: center;
            width: 100%;
            margin-bottom: 20px;
        }

        .container {
            display: flex;
            max-width: 1200px;
            width: 95%;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin: 20px auto;
        }

        .pseudocode-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
        }

        .pseudocode-image:hover {
            transform: scale(1.02);
        }

        .sidebar {
            background-color: #f8f9fa;
            padding: 20px;
            border-right: 1px solid #dee2e6;
            width: 280px;
            flex-shrink: 0;
        }

        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar li a {
            display: block;
            padding: 12px 18px;
            text-decoration: none;
            color: #495057;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .sidebar li a:hover,
        .sidebar li a.active {
            background-color: #e9ecef;
            color: #007bff;
        }

        .sidebar .download-btn {
            display: block;
            background-color: #007bff;
            color: white;
            padding: 14px 18px;
            text-decoration: none;
            border-radius: 5px;
            text-align: center;
            margin-top: 25px;
            transition: background-color 0.3s ease;
        }

        .sidebar .download-btn:hover {
            background-color: #0056b3;
        }

        .main-content {
            padding: 30px;
            flex-grow: 1;
        }

        .main-content h1 {
            color: #343a40;
            margin-bottom: 15px;
            font-size: 2.2em;
        }

        .main-content p {
            color: #495057;
            line-height: 1.8;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .main-content h2 {
            color: #343a40;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.6em;
        }

        .main-content ul {
            padding-left: 25px;
            margin-bottom: 20px;
            list-style-type: disc;
            color: #495057;
            font-size: 1.1em;
        }

        .main-content ul li {
            margin-bottom: 8px;
        }

        .sidebar ul ul {
            margin-left: 20px;
            margin-top: 5px;
        }

        .sidebar ul ul li a {
            font-size: 0.9em;
        }

        pre code {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            display: block;
        }

        .topic-section h2 {
            margin-bottom: #333;
            color: #333;
        }

        ol {
            padding-left: 25px;
            margin-bottom: 20px;
        }

        ol li {
            margin-bottom: 8px;
        }

        .image-container {
            text-align: center;
            margin: 20px auto;
            padding: 10px;
            max-width: 1000px;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            display: inline-block;
        }

        .subtopic-content {
            display: none;
        }

        .subtopic-content.active {
            display: block;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Unit 4: Pointers in C</h1>
    </div>
    <div class="container">
        <div class="sidebar">
            <div class="topic-section">
                <h2>Pointers</h2>
                <ul>
                    <li><a href="#pointers-introduction">Introduction to Pointers</a></li>
                    <li><a href="#pointers-memory">Understanding Computer Memory</a></li>
                    <li><a href="#pointers-declaration">Declaration and Initialization of Pointers</a></li>
                    <li><a href="#pointers-arithmetic">Pointer Arithmetic</a></li>
                    <li><a href="#pointers-strings">Pointers and Strings</a></li>
                    <li><a href="#pointers-arrays">Array of Pointers</a></li>
                    <li><a href="#pointers-functions">Pointers to Functions</a></li>
                    <li><a href="#pointers-dynamic">Dynamic Memory Allocation</a></li>
                    <li><a href="#pointers-advantages">Advantages and Drawbacks of Pointers</a></li>
                </ul>
            </div>
            <a href="https://drive.google.com/file/d/19wdNDg1Fttz67atma5HdtiL2W6bNkg0j/view?usp=drive_link"
                class="download-btn">Download PDF</a>
        </div>
        <div class="main-content">
            
			<div id="pointers-introduction" class="subtopic-content">
				<h2>Introduction to Pointers</h2>
				<p>
					In C programming, a <strong>pointer</strong> is a variable that stores the memory address of another variable. Pointers are fundamental to C as they provide direct access to memory locations, enabling efficient array handling, dynamic memory allocation, and the creation of complex data structures like linked lists and trees.
				</p>

				<h3>Understanding Memory Addresses</h3>
				<p>
					Every variable in a C program is stored at a specific memory address. The pointer contains the address of the variable it points to, allowing indirect manipulation of the variable's value.
				</p>

				<h3>Declaring and Initializing Pointers</h3>
				<p>
					To declare a pointer, specify the data type it will point to, followed by an asterisk (<code>*</code>), and then the pointer's name. For example:
				</p>
				<pre><code>
			int *ptr;
				</code></pre>
				<p>
					Here, <code>ptr</code> is a pointer to an integer. To initialize this pointer, assign it the address of an existing integer variable using the address-of operator (<code>&amp;</code>):
				</p>
				<pre><code>
			int num = 10;
			int *ptr = &num;
				</code></pre>

				<h3>Dereferencing a Pointer</h3>
				<p>
					Dereferencing a pointer means accessing or modifying the value at the memory address the pointer is pointing to. This is done using the dereference operator (<code>*</code>):
				</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int num = 10;
				int *ptr = &num;

				printf("Value of num: %d\n", num);      // Outputs: 10
				printf("Address of num: %p\n", &num);   // Outputs: Address of num
				printf("Value of ptr: %p\n", ptr);      // Outputs: Address of num
				printf("Value pointed by ptr: %d\n", *ptr); // Outputs: 10

				return 0;
			}
				</code></pre>

				<h3>Pointer Arithmetic</h3>
				<p>
					Pointers can be incremented or decremented to traverse memory. When a pointer is incremented, it points to the next memory location of its type. For example:
				</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int arr[3] = {10, 20, 30};
				int *ptr = arr;

				printf("First element: %d\n", *ptr);       // Outputs: 10
				ptr++;
				printf("Second element: %d\n", *ptr);      // Outputs: 20
				ptr++;
				printf("Third element: %d\n", *ptr);       // Outputs: 30

				return 0;
			}
				</code></pre>

				<h3>Common Mistakes with Pointers</h3>
				<p>
					Working with pointers requires caution. Common mistakes include:
				</p>
				<ul>
					<li><strong>Uninitialized Pointers:</strong> Using a pointer that hasn't been initialized can lead to undefined behavior.</li>
					<li><strong>Dereferencing NULL Pointers:</strong> Dereferencing a pointer that points to NULL can cause a program to crash.</li>
					<li><strong>Memory Leaks:</strong> Failing to free dynamically allocated memory can lead to memory leaks.</li>
				</ul>
				<a href="#" class="back-link">Back to Top</a>
			</div>

			<div id="pointers-memory" class="subtopic-content">
				<h2>Understanding Computer Memory and Pointers in C</h2>
				<p>In C programming, a <strong>pointer</strong> is a variable that stores the memory address of another variable. This allows for efficient array handling, dynamic memory allocation, and the creation of complex data structures like linked lists. Understanding how pointers interact with computer memory is essential for effective C programming.</p>

				<h3>Memory Layout in C</h3>
				<p>Computer memory is organized into distinct sections, each serving a specific purpose in a C program:</p>
				<ul>
					<li><strong>Text Segment:</strong> Contains the compiled code of the program.</li>
					<li><strong>Data Segment:</strong> Stores global and static variables. It's divided into:
						<ul>
							<li><strong>Initialized Data Segment:</strong> For variables that are initialized with a specific value.</li>
							<li><strong>Uninitialized Data Segment (BSS):</strong> For variables that are declared but not initialized.</li>
						</ul>
					</li>
					<li><strong>Heap:</strong> Used for dynamic memory allocation during program execution.</li>
					<li><strong>Stack:</strong> Manages function calls, local variables, and control flow.</li>
				</ul>
				<p>Understanding this layout helps in managing memory effectively and avoiding issues like memory leaks and segmentation faults.</p>

				<h3>Declaring and Using Pointers</h3>
				<p>To declare a pointer in C, use the asterisk (<code>*</code>) symbol. For example:</p>
				<pre><code>
			int var = 10;
			int *ptr = &var;
				</code></pre>
				<p>Here, <code>var</code> is an integer variable, and <code>ptr</code> is a pointer that holds the address of <code>var</code>. The ampersand (<code>&amp;</code>) operator is used to get the address of a variable.</p>

				<h3>Dereferencing Pointers</h3>
				<p>Dereferencing a pointer means accessing the value stored at the memory address the pointer holds. This is done using the asterisk (<code>*</code>) operator:</p>
				<pre><code>
			printf("%d\n", *ptr); // Outputs: 10
				</code></pre>
				<p>In this example, <code>*ptr</code> accesses the value at the address stored in <code>ptr</code>, which is 10.</p>

				<h3>Pointer Arithmetic</h3>
				<p>Pointers can be incremented or decremented to traverse arrays or memory blocks. When a pointer is incremented, it points to the next memory location of its type:</p>
				<pre><code>
			int arr[3] = {10, 20, 30};
			int *ptr = arr;
			ptr++; // Now points to arr[1]
				</code></pre>
				<p>Here, <code>ptr</code> initially points to the first element of the array. After incrementing, it points to the second element.</p>

				<h3>Common Mistakes with Pointers</h3>
				<p>Working with pointers requires caution to avoid common pitfalls:</p>
				<ul>
					<li><strong>Uninitialized Pointers:</strong> Always initialize pointers before use to avoid undefined behavior.</li>
					<li><strong>Dereferencing Null Pointers:</strong> Ensure pointers are not null before dereferencing to prevent crashes.</li>
					<li><strong>Memory Leaks:</strong> Always free dynamically allocated memory using <code>free()</code> to avoid memory leaks.</li>
				</ul>
				
				<a href="#" class="back-link">Back to Top</a>
			</div>
			
			
			<div id="pointers-declaration" class="subtopic-content">
				<h2>Declaration and Initialization of Pointers</h2>
				<p>
					In C programming, a <strong>pointer</strong> is a variable that stores the memory address of another variable. Proper declaration and initialization of pointers are crucial for efficient and error-free code.
				</p>

				<h3>Declaring a Pointer</h3>
				<p>
					To declare a pointer, specify the data type it will point to, followed by an asterisk (<code>*</code>), and then the pointer's name. The syntax is:
				</p>
				<pre><code>
			data_type *pointer_name;
				</code></pre>
				<p>
					For example, to declare a pointer to an integer:
				</p>
				<pre><code>
			int *ptr;
				</code></pre>
				<p>
					Here, <code>ptr</code> is a pointer to an integer.
				</p>

				<h3>Initializing a Pointer</h3>
				<p>
					After declaration, a pointer should be initialized to point to a specific variable or set to <code>NULL</code> to avoid undefined behavior. Initialization is done using the address-of operator (<code>&amp;</code>):
				</p>
				<pre><code>
			int num = 20;
			int *ptr = &num; // ptr now holds the address of num
				</code></pre>
				<p>
					In this example, <code>ptr</code> is initialized with the address of <code>num</code>.
				</p>

				<h3>Example: Declaration and Initialization</h3>
				<p>
					The following program demonstrates the declaration and initialization of a pointer:
				</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int num = 20;
				int *ptr = &num; // Declaration and initialization

				printf("Value of num: %d\n", num);
				printf("Address of num: %p\n", (void*)&num);
				printf("Value of ptr: %p\n", (void*)ptr);
				printf("Value pointed by ptr: %d\n", *ptr);

				return 0;
			}
				</code></pre>
				<p>
					Output:
				</p>
				<pre><code>
			Value of num: 20
			Address of num: 0x7ffee4b8c8ac
			Value of ptr: 0x7ffee4b8c8ac
			Value pointed by ptr: 20
				</code></pre>
				<p>
					This program declares an integer variable <code>num</code> and a pointer <code>ptr</code> that is initialized to the address of <code>num</code>. It then prints the value and address of <code>num</code>, the value stored in <code>ptr</code>, and the value pointed to by <code>ptr</code>.
				</p>

				<h3>Pointer to Pointer (Double Pointer)</h3>
				<p>
					C allows the use of pointers to pointers, enabling multiple levels of indirection. A pointer to a pointer is declared using two asterisks:
				</p>
				<pre><code>
			int **ptr_to_ptr;
				</code></pre>
				<p>
					Here's an example demonstrating a pointer to a pointer:
				</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int num = 30;
				int *ptr = &num;
				int **ptr_to_ptr = &ptr;

				printf("Value of num: %d\n", num);
				printf("Value pointed by ptr: %d\n", *ptr);
				printf("Value pointed by ptr_to_ptr: %d\n", **ptr_to_ptr);

				return 0;
			}
				</code></pre>
				<p>
					Output:
				</p>
				<pre><code>
			Value of num: 30
			Value pointed by ptr: 30
			Value pointed by ptr_to_ptr: 30
				</code></pre>
				<p>
					In this example, <code>ptr</code> is a pointer to <code>num</code>, and <code>ptr_to_ptr</code> is a pointer to <code>ptr</code>. Dereferencing <code>ptr_to_ptr</code> twice yields the value of <code>num</code>.
				</p>

				<h3>Common Mistakes and Best Practices</h3>
				<p>
					When working with pointers, it's essential to avoid common pitfalls:
				</p>
				<ul>
					<li><strong>Uninitialized Pointers:</strong> Always initialize pointers before use to prevent undefined behavior.</li>
					<li><strong>Dereferencing NULL Pointers:</strong> Ensure pointers are not <code>NULL</code> before dereferencing to avoid crashes.</li>
					<li><strong>Pointer Type Mismatch:</strong> Assign pointers to variables of matching data types to prevent type-related errors.</li>
				</ul>
				<p>
					Best practices include:
				</p>
				<ul>
					<li>Use meaningful pointer names to enhance code readability.</li>
					<li>Set pointers to <code>NULL</code> after freeing them to prevent dangling pointers.</li>
					<li>Regularly check for memory leaks when using dynamic memory allocation.</li>
				</ul>
				
				<a href="#" class="back-link">Back to Top</a>
			</div>

			<div id="pointers-arithmetic" class="subtopic-content">
				<h2>Pointer Arithmetic in C</h2>
				<p>In C, pointers store memory addresses, and pointer arithmetic enables navigation through contiguous memory locations, such as arrays. When you perform arithmetic operations on pointers, the compiler adjusts the pointer's address based on the size of the data type it points to.</p>

				<h3>Basic Operations</h3>
				<p>The primary operations you can perform on pointers include:</p>
				<ul>
					<li><strong>Addition:</strong> Incrementing a pointer moves it forward by a number of elements. For example, <code>ptr + 1</code> advances the pointer by one element.</li>
					<li><strong>Subtraction:</strong> Decrementing a pointer moves it backward by a number of elements. For instance, <code>ptr - 1</code> moves the pointer back by one element.</li>
					<li><strong>Difference:</strong> Subtracting one pointer from another gives the number of elements between them.</li>
				</ul>

				<h3>Example: Navigating an Array</h3>
				<p>Consider an array of integers and a pointer used to traverse it:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int arr[] = {10, 20, 30, 40, 50};
				int *ptr = arr; // Pointing to the first element

				printf("Initial value at ptr: %d\n", *ptr);

				ptr++; // Move to the next element
				printf("Value after ptr++: %d\n", *ptr);

				ptr += 2; // Move two elements ahead
				printf("Value after ptr += 2: %d\n", *ptr);

				ptr--; // Move back one element
				printf("Value after ptr--: %d\n", *ptr);

				return 0;
			}
				</code></pre>
				<p>In this example, the pointer <code>ptr</code> is used to navigate through the array <code>arr</code> by incrementing and decrementing its position.</p>

				<h3>Pointer Subtraction</h3>
				<p>You can also subtract pointers to determine the distance between two elements in an array:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int arr[] = {5, 15, 25, 35, 45};
				int *ptr1 = &arr[1]; // Points to arr[1]
				int *ptr2 = &arr[4]; // Points to arr[4]

				int distance = ptr2 - ptr1;
				printf("Number of elements between ptr1 and ptr2: %d\n", distance);

				return 0;
			}
				</code></pre>
				<p>Here, <code>ptr2 - ptr1</code> calculates the number of elements between the two pointers, which is 3.</p>

				<h3>Important Considerations</h3>
				<ul>
					<li><strong>Data Type Size:</strong> Pointer arithmetic takes into account the size of the data type. For example, if <code>int</code> is 4 bytes, incrementing an <code>int</code> pointer increases its address by 4 bytes.</li>
					<li><strong>Valid Operations:</strong> Pointer arithmetic is primarily valid within the same array. Performing arithmetic that moves the pointer outside the bounds of the array can lead to undefined behavior.</li>
					<li><strong>Pointer Comparison:</strong> Pointers to elements of the same array can be compared using relational operators.</li>
				</ul>
				
				<a href="#" class="back-link">Back to Top</a>
			</div>
					 
			<div id="pointers-strings" class="subtopic-content">
				<h2>Pointers and Strings</h2>
				<p>In C, strings are arrays of characters, and pointers are commonly used to manipulate them.
					A string literal is essentially a pointer to the first character of the string.</p>

				<h3>Basic Example</h3>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				char str[] = "Hello";
				char *ptr = str;

				while (*ptr != '\0') {
					printf("%c", *ptr);
					ptr++;
				}

				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			Hello
				</code></pre>

				<h3>Modifying Strings Using Pointers</h3>
				<p>Pointers can also be used to modify string content directly.</p>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;ctype.h&gt; // For toupper function

			int main() {
				char str[] = "Hello, World!";
				char *ptr = str;

				while (*ptr != '\0') {
					*ptr = toupper(*ptr); // Convert character to uppercase
					ptr++;
				}

				printf("Uppercase String: %s\n", str);
				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			Uppercase String: HELLO, WORLD!
				</code></pre>

				<h3>Pointer to String Literal</h3>
				<p>A string literal can be directly assigned to a <code>const char*</code> pointer.</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				const char *ptr = "Hello, World!";
				printf("String literal: %s\n", ptr);
				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			String literal: Hello, World!
				</code></pre>

				<h3>Visual Representation of Pointers and Strings</h3>
				<p>The memory layout for the string <code>char str[] = "Hello";</code> is:</p>
				<table border="1" cellpadding="5">
					<tr><th>Address</th><th>Value</th><th>Variable</th></tr>
					<tr><td>0x1000</td><td>'H'</td><td>str[0]</td></tr>
					<tr><td>0x1001</td><td>'e'</td><td>str[1]</td></tr>
					<tr><td>0x1002</td><td>'l'</td><td>str[2]</td></tr>
					<tr><td>0x1003</td><td>'l'</td><td>str[3]</td></tr>
					<tr><td>0x1004</td><td>'o'</td><td>str[4]</td></tr>
					<tr><td>0x1005</td><td>'\0'</td><td>str[5]</td></tr>
				</table>

				<h3>Illustrative Image</h3>
				<img src="https://tse1.mm.bing.net/th?id=OIP.4kzkp9e7i1tppOJh7UutpQHaCV&pid=Api" alt="Pointers and Strings Illustration" style="max-width:100%; height:auto; border:1px solid #ccc; border-radius:8px; margin-top:10px;">

				<h3>Best Practices</h3>
				<ul>
					<li>Use <code>const char*</code> for string literals to avoid modification.</li>
					<li>Ensure strings are null-terminated to prevent undefined behavior.</li>
					<li>Be careful with pointer arithmetic to avoid memory access errors.</li>
				</ul>
				
				<a href="#" class="back-link">Back to Top</a>
			</div>
						
            
			<div id="pointers-arrays" class="subtopic-content">
				<h2>Array of Pointers in C</h2>
				<p>In C programming, an array of pointers allows efficient management of multiple strings or dynamic data structures. Each element in this array holds the address of a variable or a memory location.</p>

				<h3>Declaration and Initialization</h3>
				<p>To declare an array of pointers, specify the pointer type followed by the array name and its size. For example:</p>
				<pre><code>
			int *ptrArray[3];
				</code></pre>
				<p>This declares an array <code>ptrArray</code> of three integer pointers.</p>

				<h3>Example: Array of Strings</h3>
				<p>One common use of an array of pointers is to store an array of strings. Here's an example:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				char *names[] = {"Alice", "Bob", "Charlie"};
				int size = sizeof(names) / sizeof(names[0]);

				for (int i = 0; i &lt; size; i++) {
					printf("%s\n", names[i]);
				}

				return 0;
			}
				</code></pre>
				<p>In this example, <code>names</code> is an array of pointers, each pointing to the first character of a string literal. The program prints each name by dereferencing the pointers.</p>

				<h3>Example: Array of Integer Pointers</h3>
				<p>Another example involves an array of pointers to integers:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int main() {
				int a = 10, b = 20, c = 30;
				int *ptrArray[3];

				ptrArray[0] = &a;
				ptrArray[1] = &b;
				ptrArray[2] = &c;

				for (int i = 0; i &lt; 3; i++) {
					printf("Value at ptrArray[%d]: %d\n", i, *ptrArray[i]);
				}

				return 0;
			}
				</code></pre>
				<a href="#" class="back-link">Back to Top</a>
			</div>
					   
			<div id="pointers-functions" class="subtopic-content">
				<h2>Pointers to Functions</h2>
				<p>Pointers to functions store the address of a function. This allows functions to be passed as arguments to other functions, returned from functions, and invoked dynamically at runtime.</p>

				<h3>Basic Example</h3>
				<pre><code>
			#include &lt;stdio.h&gt;

			int add(int a, int b) {
				return a + b;
			}

			int main() {
				int (*ptr)(int, int) = add; // ptr points to add function
				printf("Sum: %d\n", ptr(5, 3));
				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			Sum: 8
				</code></pre>

				<h3>Using Function Pointers as Parameters</h3>
				<p>You can pass function pointers to other functions to customize behavior:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int multiply(int a, int b) {
				return a * b;
			}

			int calculate(int x, int y, int (*operation)(int, int)) {
				return operation(x, y);
			}

			int main() {
				printf("Multiplication: %d\n", calculate(4, 5, multiply));
				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			Multiplication: 20
				</code></pre>

				<h3>Array of Function Pointers</h3>
				<p>Function pointers can also be stored in arrays for implementing menus or callback systems:</p>
				<pre><code>
			#include &lt;stdio.h&gt;

			int add(int a, int b) { return a + b; }
			int subtract(int a, int b) { return a - b; }

			int main() {
				int (*operations[2])(int, int) = {add, subtract};

				printf("Add: %d\n", operations[0](10, 5));
				printf("Subtract: %d\n", operations[1](10, 5));

				return 0;
			}
				</code></pre>

				<h3>Output:</h3>
				<pre><code>
			Add: 15
			Subtract: 5
				</code></pre>
				<a href="#" class="back-link">Back to Top</a>
			</div>

			<div id="pointers-dynamic" class="subtopic-content">
				<h2>Dynamic Memory Allocation in C</h2>
				<p>Dynamic memory allocation enables programs to allocate memory during execution, which is essential for handling data structures whose size may change, such as linked lists, trees, and arrays. The C standard library provides several functions to manage dynamic memory:</p>

				<h3>1. <code>malloc()</code> – Memory Allocation</h3>
				<p>The <code>malloc()</code> function allocates a specified number of bytes and returns a pointer to the first byte of the allocated space. The content of the allocated memory is uninitialized.</p>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;stdlib.h&gt;

			int main() {
				int *ptr = (int *)malloc(5 * sizeof(int)); // Allocate memory for 5 integers
				if (ptr == NULL) {
					printf("Memory allocation failed.\n");
					return 1;
				}

				// Initialize and print the allocated memory
				for (int i = 0; i &lt; 5; i++) {
					ptr[i] = i + 1;
					printf("%d ", ptr[i]);
				}

				free(ptr); // Free the allocated memory
				return 0;
			}
				</code></pre>
				<p>In this example, <code>malloc()</code> allocates memory for an array of 5 integers. It's crucial to check if the allocation was successful by verifying that the returned pointer is not <code>NULL</code>. After usage, the allocated memory is freed using <code>free()</code>.</p>

				<h3>2. <code>calloc()</code> – Contiguous Allocation</h3>
				<p>The <code>calloc()</code> function allocates memory for an array of elements, initializes all bytes to zero, and returns a pointer to the allocated space.</p>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;stdlib.h&gt;

			int main() {
				int *ptr = (int *)calloc(5, sizeof(int)); // Allocate and zero-initialize memory for 5 integers
				if (ptr == NULL) {
					printf("Memory allocation failed.\n");
					return 1;
				}

				// Print the initialized memory
				for (int i = 0; i &lt; 5; i++) {
					printf("%d ", ptr[i]); // Will print 0 for each element
				}

				free(ptr); // Free the allocated memory
				return 0;
			}
				</code></pre>
				<p>Here, <code>calloc()</code> allocates memory for 5 integers and initializes all elements to zero. This ensures that the allocated memory does not contain garbage values.</p>

				<h3>3. <code>realloc()</code> – Reallocation</h3>
				<p>The <code>realloc()</code> function resizes the memory block pointed to by a pointer to a new size. It can expand or shrink the existing memory block, and if necessary, move it to a new location.</p>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;stdlib.h&gt;

			int main() {
				int *ptr = (int *)malloc(3 * sizeof(int)); // Initially allocate memory for 3 integers
				if (ptr == NULL) {
					printf("Memory allocation failed.\n");
					return 1;
				}

				// Initialize the allocated memory
				for (int i = 0; i &lt; 3; i++) {
					ptr[i] = i + 1;
				}

				// Resize the allocated memory to hold 5 integers
				int *new_ptr = (int *)realloc(ptr, 5 * sizeof(int));
				if (new_ptr == NULL) {
					printf("Memory reallocation failed.\n");
					free(ptr); // Free the original memory
					return 1;
				}
				ptr = new_ptr;

				// Initialize the new elements
				for (int i = 3; i &lt; 5; i++) {
					ptr[i] = i + 1;
				}

				// Print the contents of the reallocated memory
				for (int i = 0; i &lt; 5; i++) {
					printf("%d ", ptr[i]);
				}

				free(ptr); // Free the reallocated memory
				return 0;
			}
				</code></pre>
				<p>In this example, <code>realloc()</code> is used to expand the memory block from 3 to 5 integers. It's important to check if <code>realloc()</code> returns <code>NULL</code>, indicating that reallocation failed.</p>

				<h3>4. <code>free()</code> – Freeing Allocated Memory</h3>
				<p>The <code>free()</code> function deallocates the memory previously allocated by <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>. Failing to free dynamically allocated memory can lead to memory leaks.</p>

				<h3>Best Practices</h3>
				<ul>
					<li>Always check if memory allocation or reallocation is successful by verifying that the returned pointer is not <code>NULL</code>.</li>
					<li>Initialize allocated memory to avoid undefined behavior due to uninitialized values.</li>
					<li>After freeing memory, set the pointer to <code>NULL</code> to prevent dangling pointers.</li>
					<li>Avoid memory leaks by ensuring that every allocated memory block is eventually freed.</li>
				</ul>
				<a href="#" class="back-link">Back to Top</a>
			</div>
									
			<div id="pointers-advantages" class="subtopic-content">
				<h2>Advantages and Drawbacks of Pointers</h2>

				<h3><strong>Advantages:</strong></h3>
				<ul>
					<li>Efficient memory management through dynamic allocation.</li>
					<li>Allows passing variables by reference, avoiding unnecessary copies.</li>
					<li>Enables the creation and manipulation of dynamic data structures (like linked lists, trees).</li>
					<li>Improves performance for array and string operations by using direct memory access.</li>
				</ul>

				<h4>Example: Passing by Reference</h4>
				<pre><code>
			#include &lt;stdio.h&gt;

			void updateValue(int *ptr) {
				*ptr = 50;
			}

			int main() {
				int x = 10;
				updateValue(&x);
				printf("Updated value: %d\n", x);
				return 0;
			}
				</code></pre>

				<h4>Output:</h4>
				<pre><code>
			Updated value: 50
				</code></pre>

				<h4>Example: Dynamic Memory Allocation</h4>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;stdlib.h&gt;

			int main() {
				int *arr;
				int n = 5;

				arr = (int*)malloc(n * sizeof(int));
				if (arr == NULL) {
					printf("Memory not allocated.\n");
					return 1;
				}

				for (int i = 0; i < n; i++) {
					arr[i] = i + 1;
				}

				for (int i = 0; i < n; i++) {
					printf("%d ", arr[i]);
				}

				free(arr);
				return 0;
			}
				</code></pre>

				<h4>Output:</h4>
				<pre><code>
			1 2 3 4 5
				</code></pre>

				<h3><strong>Drawbacks:</strong></h3>
				<ul>
					<li>Improper handling can cause memory leaks if <code>malloc()</code> is not followed by <code>free()</code>.</li>
					<li>Accessing invalid memory may lead to segmentation faults.</li>
					<li>Code involving multiple pointers can become complex and error-prone.</li>
				</ul>

				<h4>Example: Dangling Pointer (Error)</h4>
				<pre><code>
			#include &lt;stdio.h&gt;
			#include &lt;stdlib.h&gt;

			int* getPointer() {
				int x = 10;
				return &x; // returns address of a local variable (invalid!)
			}

			int main() {
				int *ptr = getPointer();
				printf("%d\n", *ptr); // undefined behavior
				return 0;
			}
				</code></pre>

				<h4>Potential Issue:</h4>
				<pre><code>
			May result in a runtime error (dangling pointer)
				</code></pre>
				
				<a href="#" class="back-link">Back to Top</a>
			</div>
					  

		  
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const sidebarLinks = document.querySelectorAll('.sidebar ul li a');
            const subtopicContents = document.querySelectorAll('.subtopic-content');

            window.onload = function () {
                const first = document.querySelector('a[href="#pointers-introduction"]');
                if (first) first.click();
            };

            sidebarLinks.forEach(link => {
                link.addEventListener('click', function (event) {
                    event.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);

                    sidebarLinks.forEach(l => l.classList.remove('active'));
                    subtopicContents.forEach(content => content.classList.remove('active'));

                    this.classList.add('active');

                    const targetEl = document.getElementById(targetId);
                    if (targetEl) targetEl.classList.add('active');
                });
            });
        });
    </script>
</body>

</html>